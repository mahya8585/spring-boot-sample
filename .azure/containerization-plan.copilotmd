# **Containerization Plan**

## **Goal**
Setup Dockerfiles for the TechBookStore project to run inside containers. Create separate Dockerfiles for backend and frontend services following modern Docker best practices.

## **List of services to be containerized**

### 1. Backend Service
- **Path**: c:/local-m/github/spring-boot-sample/backend
- **Language**: Java 21
- **Framework**: Spring Boot 3.5.0
- **Build System**: Maven
- **Entry Point**: com.techbookstore.app.TechBookStoreApplication
- **Port**: 8080
- **Dependencies**: 
  - PostgreSQL (database)
  - H2 (in-memory database for dev/test)
  - Redis (caching)
  - Azure Key Vault (secrets management)
- **Key Features**: REST API, JPA/Hibernate, Spring Security, I18n support

### 2. Frontend Service
- **Path**: c:/local-m/github/spring-boot-sample/frontend
- **Language**: JavaScript (React 16.13.1)
- **Framework**: React with Material-UI 4.x
- **Build System**: npm
- **Port**: 3000 (dev), static files for production
- **Dependencies**:
  - React Router DOM
  - Redux for state management
  - Axios for API calls
  - Recharts for data visualization
- **Key Features**: SPA, I18n context, responsive UI

## **Execution Steps**

> **Below are the steps for Copilot to follow:**

### Step 1: Check containerization pre-requisites
- ✅ Ensure Docker is installed and running
- ✅ Verify project builds successfully locally

### Step 2: Scan the repository
- ✅ Repository analysis completed using `appmod-analyze-repository` tool
- ✅ Detected: 2 services (backend Java/Spring Boot, frontend JavaScript/React)

### Step 3: Check code is ready to run in a local container
- Review application configuration management:
  - Backend uses `application.yml` with profile support (dev/prod)
  - Frontend uses environment variables for API endpoint configuration
- Identify cloud dependencies:
  - PostgreSQL database (can use containerized version for dev)
  - Redis cache (can use containerized version for dev)
  - Azure Key Vault (production only, optional for local dev)

### Step 4: Create Dockerfiles for each project
- Generate backend Dockerfile using `appmod-plan-generate-dockerfile` tool
- Generate frontend Dockerfile using `appmod-plan-generate-dockerfile` tool
- Use multi-stage builds for optimized image sizes
- Follow security best practices (non-root user, minimal base images)

### Step 5: Build the Docker images
- Build backend image: `docker build -t techbookstore-backend:latest ./backend`
- Build frontend image: `docker build -t techbookstore-frontend:latest ./frontend`
- Tag images appropriately for versioning

### Step 6: Summarize the containerization
- Document all created Dockerfiles
- Provide instructions for building and running containers
- List any configuration changes needed
- Document environment variables required

## **Success Criteria**
- ✅ Separate Dockerfile created for backend service
- ✅ Separate Dockerfile created for frontend service
- ✅ Docker images build successfully without errors
- ✅ Images follow security and optimization best practices
- ✅ Clear documentation provided for running containers
